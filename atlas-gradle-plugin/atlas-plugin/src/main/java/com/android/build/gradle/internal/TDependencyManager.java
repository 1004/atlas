/*
 *
 *
 *                                  Apache License
 *                            Version 2.0, January 2004
 *                         http://www.apache.org/licenses/
 *
 *    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *    1. Definitions.
 *
 *       "License" shall mean the terms and conditions for use, reproduction,
 *       and distribution as defined by Sections 1 through 9 of this document.
 *
 *       "Licensor" shall mean the copyright owner or entity authorized by
 *       the copyright owner that is granting the License.
 *
 *       "Legal Entity" shall mean the union of the acting entity and all
 *       other entities that control, are controlled by, or are under common
 *       control with that entity. For the purposes of this definition,
 *       "control" means (i) the power, direct or indirect, to cause the
 *       direction or management of such entity, whether by contract or
 *       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *       outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *       "You" (or "Your") shall mean an individual or Legal Entity
 *       exercising permissions granted by this License.
 *
 *       "Source" form shall mean the preferred form for making modifications,
 *       including but not limited to software source code, documentation
 *       source, and configuration files.
 *
 *       "Object" form shall mean any form resulting from mechanical
 *       transformation or translation of a Source form, including but
 *       not limited to compiled object code, generated documentation,
 *       and conversions to other media types.
 *
 *       "Work" shall mean the work of authorship, whether in Source or
 *       Object form, made available under the License, as indicated by a
 *       copyright notice that is included in or attached to the work
 *       (an example is provided in the Appendix below).
 *
 *       "Derivative Works" shall mean any work, whether in Source or Object
 *       form, that is based on (or derived from) the Work and for which the
 *       editorial revisions, annotations, elaborations, or other modifications
 *       represent, as a whole, an original work of authorship. For the purposes
 *       of this License, Derivative Works shall not include works that remain
 *       separable from, or merely link (or bind by name) to the interfaces of,
 *       the Work and Derivative Works thereof.
 *
 *       "Contribution" shall mean any work of authorship, including
 *       the original version of the Work and any modifications or additions
 *       to that Work or Derivative Works thereof, that is intentionally
 *       submitted to Licensor for inclusion in the Work by the copyright owner
 *       or by an individual or Legal Entity authorized to submit on behalf of
 *       the copyright owner. For the purposes of this definition, "submitted"
 *       means any form of electronic, verbal, or written communication sent
 *       to the Licensor or its representatives, including but not limited to
 *       communication on electronic mailing lists, source code control systems,
 *       and issue tracking systems that are managed by, or on behalf of, the
 *       Licensor for the purpose of discussing and improving the Work, but
 *       excluding communication that is conspicuously marked or otherwise
 *       designated in writing by the copyright owner as "Not a Contribution."
 *
 *       "Contributor" shall mean Licensor and any individual or Legal Entity
 *       on behalf of whom a Contribution has been received by Licensor and
 *       subsequently incorporated within the Work.
 *
 *    2. Grant of Copyright License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       copyright license to reproduce, prepare Derivative Works of,
 *       publicly display, publicly perform, sublicense, and distribute the
 *       Work and such Derivative Works in Source or Object form.
 *
 *    3. Grant of Patent License. Subject to the terms and conditions of
 *       this License, each Contributor hereby grants to You a perpetual,
 *       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *       (except as stated in this section) patent license to make, have made,
 *       use, offer to sell, sell, import, and otherwise transfer the Work,
 *       where such license applies only to those patent claims licensable
 *       by such Contributor that are necessarily infringed by their
 *       Contribution(s) alone or by combination of their Contribution(s)
 *       with the Work to which such Contribution(s) was submitted. If You
 *       institute patent litigation against any entity (including a
 *       cross-claim or counterclaim in a lawsuit) alleging that the Work
 *       or a Contribution incorporated within the Work constitutes direct
 *       or contributory patent infringement, then any patent licenses
 *       granted to You under this License for that Work shall terminate
 *       as of the date such litigation is filed.
 *
 *    4. Redistribution. You may reproduce and distribute copies of the
 *       Work or Derivative Works thereof in any medium, with or without
 *       modifications, and in Source or Object form, provided that You
 *       meet the following conditions:
 *
 *       (a) You must give any other recipients of the Work or
 *           Derivative Works a copy of this License; and
 *
 *       (b) You must cause any modified files to carry prominent notices
 *           stating that You changed the files; and
 *
 *       (c) You must retain, in the Source form of any Derivative Works
 *           that You distribute, all copyright, patent, trademark, and
 *           attribution notices from the Source form of the Work,
 *           excluding those notices that do not pertain to any part of
 *           the Derivative Works; and
 *
 *       (d) If the Work includes a "NOTICE" text file as part of its
 *           distribution, then any Derivative Works that You distribute must
 *           include a readable copy of the attribution notices contained
 *           within such NOTICE file, excluding those notices that do not
 *           pertain to any part of the Derivative Works, in at least one
 *           of the following places: within a NOTICE text file distributed
 *           as part of the Derivative Works; within the Source form or
 *           documentation, if provided along with the Derivative Works; or,
 *           within a display generated by the Derivative Works, if and
 *           wherever such third-party notices normally appear. The contents
 *           of the NOTICE file are for informational purposes only and
 *           do not modify the License. You may add Your own attribution
 *           notices within Derivative Works that You distribute, alongside
 *           or as an addendum to the NOTICE text from the Work, provided
 *           that such additional attribution notices cannot be construed
 *           as modifying the License.
 *
 *       You may add Your own copyright statement to Your modifications and
 *       may provide additional or different license terms and conditions
 *       for use, reproduction, or distribution of Your modifications, or
 *       for any such Derivative Works as a whole, provided Your use,
 *       reproduction, and distribution of the Work otherwise complies with
 *       the conditions stated in this License.
 *
 *    5. Submission of Contributions. Unless You explicitly state otherwise,
 *       any Contribution intentionally submitted for inclusion in the Work
 *       by You to the Licensor shall be under the terms and conditions of
 *       this License, without any additional terms or conditions.
 *       Notwithstanding the above, nothing herein shall supersede or modify
 *       the terms of any separate license agreement you may have executed
 *       with Licensor regarding such Contributions.
 *
 *    6. Trademarks. This License does not grant permission to use the trade
 *       names, trademarks, service marks, or product names of the Licensor,
 *       except as required for reasonable and customary use in describing the
 *       origin of the Work and reproducing the content of the NOTICE file.
 *
 *    7. Disclaimer of Warranty. Unless required by applicable law or
 *       agreed to in writing, Licensor provides the Work (and each
 *       Contributor provides its Contributions) on an "AS IS" BASIS,
 *       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *       implied, including, without limitation, any warranties or conditions
 *       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *       PARTICULAR PURPOSE. You are solely responsible for determining the
 *       appropriateness of using or redistributing the Work and assume any
 *       risks associated with Your exercise of permissions under this License.
 *
 *    8. Limitation of Liability. In no event and under no legal theory,
 *       whether in tort (including negligence), contract, or otherwise,
 *       unless required by applicable law (such as deliberate and grossly
 *       negligent acts) or agreed to in writing, shall any Contributor be
 *       liable to You for damages, including any direct, indirect, special,
 *       incidental, or consequential damages of any character arising as a
 *       result of this License or out of the use or inability to use the
 *       Work (including but not limited to damages for loss of goodwill,
 *       work stoppage, computer failure or malfunction, or any and all
 *       other commercial damages or losses), even if such Contributor
 *       has been advised of the possibility of such damages.
 *
 *    9. Accepting Warranty or Additional Liability. While redistributing
 *       the Work or Derivative Works thereof, You may choose to offer,
 *       and charge a fee for, acceptance of support, warranty, indemnity,
 *       or other liability obligations and/or rights consistent with this
 *       License. However, in accepting such obligations, You may act only
 *       on Your own behalf and on Your sole responsibility, not on behalf
 *       of any other Contributor, and only if You agree to indemnify,
 *       defend, and hold each Contributor harmless for any liability
 *       incurred by, or claims asserted against, such Contributor by reason
 *       of your accepting any such warranty or additional liability.
 *
 *    END OF TERMS AND CONDITIONS
 *
 *    APPENDIX: How to apply the Apache License to your work.
 *
 *       To apply the Apache License to your work, attach the following
 *       boilerplate notice, with the fields enclosed by brackets "[]"
 *       replaced with your own identifying information. (Don't include
 *       the brackets!)  The text should be enclosed in the appropriate
 *       comment syntax for the file format. We also recommend that a
 *       file or class name and description of purpose be included on the
 *       same "printed page" as the copyright notice for easier
 *       identification within third-party archives.
 *
 *    Copyright 2016 Alibaba Group
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 *
 *
 */

package com.android.build.gradle.internal;

import com.alibaba.fastjson.JSON;
import com.android.annotations.NonNull;
import com.android.annotations.Nullable;
import com.android.build.gradle.internal.dependency.JarInfo;
import com.android.build.gradle.internal.dependency.LibInfo;
import com.android.build.gradle.internal.dependency.LibraryDependencyImpl;
import com.android.build.gradle.internal.dependency.VariantDependencies;
import com.android.build.gradle.internal.tasks.PrepareLibraryTask;
import com.android.builder.dependency.JarDependency;
import com.android.builder.dependency.LibraryDependency;
import com.android.builder.model.MavenCoordinates;
import com.android.builder.model.SyncIssue;
import com.android.utils.ILogger;
import com.google.common.collect.*;
import com.taobao.android.builder.AtlasBuildContext;
import com.taobao.android.builder.dependency.*;
import com.taobao.android.builder.tools.PerfMonitor;
import org.apache.commons.lang.StringUtils;
import org.gradle.api.Project;
import org.gradle.api.Task;
import org.gradle.api.UnknownProjectException;
import org.gradle.api.artifacts.*;
import org.gradle.api.artifacts.component.ComponentIdentifier;
import org.gradle.api.artifacts.component.ComponentSelector;
import org.gradle.api.artifacts.component.ProjectComponentIdentifier;
import org.gradle.api.artifacts.result.DependencyResult;
import org.gradle.api.artifacts.result.ResolvedComponentResult;
import org.gradle.api.artifacts.result.ResolvedDependencyResult;
import org.gradle.api.artifacts.result.UnresolvedDependencyResult;
import org.gradle.api.logging.Logging;
import org.gradle.api.plugins.JavaBasePlugin;
import org.gradle.api.specs.Specs;
import org.gradle.util.GUtil;

import java.io.File;
import java.util.*;

import static com.android.SdkConstants.DOT_JAR;
import static com.android.builder.core.ErrorReporter.EvaluationMode.STANDARD;
import static com.android.builder.model.AndroidProject.FD_INTERMEDIATES;
import static com.google.common.base.Preconditions.checkState;

/**
 * DependencyManager的扩展类,改用自定义的依赖仲裁进行处理
 * Created by shenghua.nish on 2016-05-04 下午3:18.
 */
public class TDependencyManager extends DependencyManager {

    private ExtraModelInfo extraModelInfo;
    private Project project;
    private ILogger logger;

    public TDependencyManager(Project project, ExtraModelInfo extraModelInfo) {
        super(project, extraModelInfo);
        this.extraModelInfo = extraModelInfo;
        this.project = project;
        logger = new LoggerWrapper(Logging.getLogger(TDependencyManager.class));

    }

    public void resolveDependencies(@NonNull VariantDependencies variantDeps,
                                    @Nullable VariantDependencies testedVariantDeps,
                                    @Nullable String testedProjectPath) {

        long startTime = System.currentTimeMillis();

        Multimap<LibraryDependency, VariantDependencies> reverseMap = ArrayListMultimap.create();
        if (extraModelInfo.isLibrary()) {

            super.resolveDependencies(variantDeps, testedVariantDeps, testedProjectPath);

        } else {
            resolveDependencyForApplicationConfig(variantDeps, testedVariantDeps, testedProjectPath, reverseMap);
            processLibraries(variantDeps.getLibraries(), reverseMap);
        }

        PerfMonitor.keyPoints.add("[resolveDependencies] " + variantDeps.getName() + ">>" + (System.currentTimeMillis() - startTime));

    }

    private void processLibraries(@NonNull Collection<LibraryDependencyImpl> libraries,
                                  @NonNull Multimap<LibraryDependency, VariantDependencies> reverseMap) {
        for (LibraryDependencyImpl lib : libraries) {
            setupPrepareLibraryTask(lib, reverseMap);
            // noinspection unchecked
            processLibraries((Collection<LibraryDependencyImpl>) (List<?>) lib.getDependencies(), reverseMap);
        }
    }

    private void setupPrepareLibraryTask(@NonNull LibraryDependencyImpl libDependency,
                                         @NonNull Multimap<LibraryDependency, VariantDependencies> reverseMap) {
        Task task = maybeCreatePrepareLibraryTask(libDependency, project);

        // Use the reverse map to find all the configurations that included this android
        // library so that we can make sure they are built.
        // TODO fix, this is not optimum as we bring in more dependencies than we should.
        Collection<VariantDependencies> configDepList = reverseMap.get(libDependency);
        if (configDepList != null && !configDepList.isEmpty()) {
            for (VariantDependencies configDependencies : configDepList) {
                task.dependsOn(configDependencies.getCompileConfiguration().getBuildDependencies());
            }
        }

        // check if this library is created by a parent (this is based on the
        // output file.
        // TODO Fix this as it's fragile
        /*
        This is a somewhat better way but it doesn't work in some project with
        weird setups...
        Project parentProject = DependenciesImpl.getProject(library.getBundle(), projects)
        if (parentProject != null) {
            String configName = library.getProjectVariant()
            if (configName == null) {
                configName = "default"
            }
        
            prepareLibraryTask.dependsOn parentProject.getPath() + ":assemble${configName.capitalize()}"
        }
        */

    }

    /**
     * Handles the library and returns a task to "prepare" the library (ie unarchive it). The task
     * will be reused for all projects using the same library.
     *
     * @param library the library.
     * @param project the project
     * @return the prepare task.
     */
    private PrepareLibraryTask maybeCreatePrepareLibraryTask(@NonNull LibraryDependencyImpl library,
                                                             @NonNull Project project) {

        // create proper key for the map. library here contains all the dependencies which
        // are not relevant for the task (since the task only extract the aar which does not
        // include the dependencies.
        // However there is a possible case of a rewritten dependencies (with resolution strategy)
        // where the aar here could have different dependencies, in which case we would still
        // need the same task.
        // So we extract a LibraryBundle (no dependencies) from the LibraryDependencyImpl to
        // make the map key that doesn't take into account the dependencies.
        LibraryDependencyImpl key = library.getNonTransitiveRepresentation();

        PrepareLibraryTask prepareLibraryTask = prepareTaskMap.get(key);

        if (prepareLibraryTask == null) {
            String bundleName = GUtil.toCamelCase(library.getName().replaceAll("\\:", " "));

            prepareLibraryTask = project.getTasks().create("prepare" + bundleName + "Library",
                    PrepareLibraryTask.class);

            prepareLibraryTask.setDescription("Prepare " + library.getName());
            prepareLibraryTask.setBundle(library.getBundle());
            prepareLibraryTask.setExplodedDir(library.getBundleFolder());
            prepareLibraryTask.setVariantName("");

            prepareTaskMap.put(key, prepareLibraryTask);
        }

        return prepareLibraryTask;
    }

    /**
     * 对application使用自己的依赖解析
     *
     * @param variantDeps
     * @param testedVariantDeps
     * @param testedProjectPath
     * @param reverseMap
     */
    private void resolveDependencyForApplicationConfig(@NonNull VariantDependencies variantDeps,
                                                       @Nullable VariantDependencies testedVariantDeps,
                                                       @Nullable String testedProjectPath,
                                                       @NonNull Multimap<LibraryDependency, VariantDependencies> reverseMap) {

        long startTime = System.currentTimeMillis();

        Configuration compileClasspath = variantDeps.getCompileConfiguration();
        Configuration packageClasspath = variantDeps.getPackageConfiguration();

        // TODO - shouldn't need to do this - fix this in Gradle
        ensureConfigured(compileClasspath);
        ensureConfigured(packageClasspath);

        long endensureConfigured = System.currentTimeMillis();
        logger.info("[TdependencyManager] ensureConfigured " + (endensureConfigured - startTime));

        if (DEBUG_DEPENDENCY) {
            logger.info(">>>>>>>>>>");
            logger.info(project.getName() + ":" + compileClasspath.getName() + "/" + packageClasspath.getName());
        }

        Set<String> currentUnresolvedDependencies = Sets.newHashSet();
        Set<String> resolvedModules = Sets.newHashSet();

        // TODO - defer downloading until required -- This is hard to do as we need the info to build the variant
        // config.
        Map<ModuleVersionIdentifier, List<ResolvedArtifact>> artifacts = Maps.newHashMap();
        collectArtifacts(compileClasspath, artifacts);
        collectArtifacts(packageClasspath, artifacts);
        long endcollectArtifacts = System.currentTimeMillis();
        logger.info("[TdependencyManager] collectArtifacts " + (endcollectArtifacts - endensureConfigured));


        // 不使用官方的扁平化的依赖处理，改用自己处理树状的依赖关系;对于application的依赖，我们只取compile的依赖
        ResolvedDependencyContainer compileResolvedDependencyContainer = new ResolvedDependencyContainer();
        Set<ModuleVersionIdentifier> directDependencies = new HashSet<ModuleVersionIdentifier>();
        Set<? extends DependencyResult> projectDependencies = compileClasspath.getIncoming().getResolutionResult().getRoot().getDependencies();
        for (DependencyResult dependencyResult : projectDependencies) {
            if (dependencyResult instanceof ResolvedDependencyResult) {
                ModuleVersionIdentifier moduleVersion = ((ResolvedDependencyResult) dependencyResult).getSelected().getModuleVersion();
                CircleDependencyCheck circleDependencyCheck = new CircleDependencyCheck(moduleVersion);

                if (!directDependencies.contains(moduleVersion)) {
                    directDependencies.add(moduleVersion);
                    resolveDependency(compileResolvedDependencyContainer, null,
                            ((ResolvedDependencyResult) dependencyResult).getSelected(), artifacts,
                            variantDeps, 0, circleDependencyCheck,
                            circleDependencyCheck.getRootDependencyNode(), resolvedModules);
                }
            } else if (dependencyResult instanceof UnresolvedDependencyResult) {
                ComponentSelector attempted = ((UnresolvedDependencyResult) dependencyResult).getAttempted();
                if (attempted != null) {
                    currentUnresolvedDependencies.add(attempted.toString());
                }
            }
        }

        long endresolve = System.currentTimeMillis();
        logger.info("[TdependencyManager] endresolve " + (endresolve - endcollectArtifacts));


        AndroidDependencyTree androidDependencyTree = compileResolvedDependencyContainer.reslovedDependencies().toAndroidDependency();

        AtlasBuildContext.androidDependencyTrees.put(variantDeps.getName(), androidDependencyTree);

        //output tree file only once
        if (project.getLogger().isInfoEnabled()) {
            project.getLogger().info("[dependencyTree" + variantDeps.getName() + "]" + JSON.toJSONString(androidDependencyTree.getDependencyJson(), true));
        }

        // 设置reverseMap
        for (LibInfo libInfo : androidDependencyTree.getAarBundles()) {
            reverseMap.put(libInfo, variantDeps);
        }

        // 2. merge jar dependencies with a single list where items have packaged/compiled properties.
        // since we reuse the same instance of a JarInfo for identical modules, we can use an
        // Identity set (ie both compiledJars and packagedJars will contain the same instance
        // if it's both compiled and packaged)
        Set<JarInfo> jarInfoSet = Sets.newIdentityHashSet();

        // go through the graphs of dependencies (jars and libs) and gather all the transitive
        // jar dependencies.
        // At the same this we set the compiled/packaged properties.
        gatherJarDependencies(jarInfoSet, androidDependencyTree.getJars(), true /* compiled */, true /* packaged */);

        // the final list of JarDependency, created from the list of JarInfo.
        List<JarDependency> jars = Lists.newArrayListWithCapacity(jarInfoSet.size());
        Set<LibInfo> librariesToKeep = Sets.newHashSetWithExpectedSize(androidDependencyTree.getAarBundles().size());
        // if this is a test dependencies (ie tested dependencies is non null), override
        // packaged attributes for jars that are already in the tested dependencies in order to
        // not package them twice (since the VM loads the classes of both APKs in the same
        // classpath and refuses to load the same class twice)
        if (testedVariantDeps != null) {
            List<JarDependency> jarDependencies = testedVariantDeps.getJarDependencies();

            // gather the tested dependencies
            Map<String, String> testedJarDeps = Maps.newHashMapWithExpectedSize(jarDependencies.size());

            for (JarDependency jar : jarDependencies) {
                if (jar.isPackaged()) {
                    MavenCoordinates coordinates = jar.getResolvedCoordinates();
                    checkState(coordinates != null);
                    testedJarDeps.put(computeVersionLessCoordinateKey(coordinates), coordinates.getVersion());
                }
            }

            // now go through all the test dependencies and check we don't have the same thing.
            // Skip the ones that are already in the tested variant, and convert the rest
            // to the final immutable instance
            for (JarInfo jar : jarInfoSet) {
                if (jar.isPackaged()) {
                    MavenCoordinates coordinates = jar.getResolvedCoordinates();

                    String testedVersion = testedJarDeps.get(computeVersionLessCoordinateKey(coordinates));
                    if (testedVersion != null) {
                        skipTestDependency(variantDeps, coordinates, testedVersion);
                    } else {
                        // new artifact, convert it.
                        jars.add(jar.createJarDependency());
                    }
                }
            }

            List<? extends LibraryDependency> androidDependencies = testedVariantDeps.getAndroidDependencies();

            Map<String, String> testedAndroidDeps = Maps.newHashMapWithExpectedSize(jarDependencies.size());
            for (LibraryDependency androidDependency : androidDependencies) {
                MavenCoordinates coordinates = androidDependency.getResolvedCoordinates();
                checkState(coordinates != null);

                testedAndroidDeps.put(computeVersionLessCoordinateKey(coordinates), coordinates.getVersion());

            }

            for (LibInfo androidLibrary : androidDependencyTree.getAarBundles()) {
                MavenCoordinates coordinates = androidLibrary.getResolvedCoordinates();
                checkState(coordinates != null);

                String testedVersion = testedAndroidDeps.get(computeVersionLessCoordinateKey(coordinates));

                if (testedVersion != null) {
                    skipTestDependency(variantDeps, coordinates, testedVersion);
                } else {
                    librariesToKeep.add(androidLibrary);
                }
            }
        } else {
            // just convert all of them to JarDependency
            for (JarInfo jarInfo : jarInfoSet) {
                jars.add(jarInfo.createJarDependency());
            }
            librariesToKeep.addAll(androidDependencyTree.getAarBundles());
        }

        // --- Handle the local jar dependencies ---

        // also need to process local jar files, as they are not processed by the
        // resolvedConfiguration result. This only includes the local jar files for this project.
        Set<File> localCompiledJars = Sets.newHashSet();
        for (Dependency dependency : compileClasspath.getAllDependencies()) {
            if (dependency instanceof SelfResolvingDependency && !(dependency instanceof ProjectDependency)) {
                Set<File> files = ((SelfResolvingDependency) dependency).resolve();
                for (File f : files) {
                    if (DEBUG_DEPENDENCY) {
                        logger.info("LOCAL compile: " + f.getName());
                    }
                    // only accept local jar, no other types.
                    if (!f.getName().toLowerCase(Locale.getDefault()).endsWith(DOT_JAR)) {
                        variantDeps.getChecker().addSyncIssue(extraModelInfo.handleSyncError(f.getAbsolutePath(),
                                SyncIssue.TYPE_NON_JAR_LOCAL_DEP,
                                String.format("Project %s: Only Jar-type local dependencies are supported. Cannot handle: %s",
                                        project.getName(),
                                        f.getAbsolutePath())));
                    } else {
                        localCompiledJars.add(f);
                    }
                }
            }
        }

        Set<File> localPackagedJars = Sets.newHashSet();
        for (Dependency dependency : packageClasspath.getAllDependencies()) {
            if (dependency instanceof SelfResolvingDependency && !(dependency instanceof ProjectDependency)) {
                Set<File> files = ((SelfResolvingDependency) dependency).resolve();
                for (File f : files) {
                    if (DEBUG_DEPENDENCY) {
                        logger.info("LOCAL package: " + f.getName());
                    }
                    // only accept local jar, no other types.
                    if (!f.getName().toLowerCase(Locale.getDefault()).endsWith(DOT_JAR)) {
                        variantDeps.getChecker().addSyncIssue(extraModelInfo.handleSyncError(f.getAbsolutePath(),
                                SyncIssue.TYPE_NON_JAR_LOCAL_DEP,
                                String.format("Project %s: Only Jar-type local dependencies are supported. Cannot handle: %s",
                                        project.getName(),
                                        f.getAbsolutePath())));
                    } else {
                        localPackagedJars.add(f);
                    }
                }
            }
        }

        // loop through both the compiled and packaged jar to compute the list
        // of jars that are: compile-only, package-only, or both.
        Map<File, JarDependency> localJars = Maps.newHashMap();
        for (File file : localCompiledJars) {
            localJars.put(file,
                    new JarDependency(file, true /* compiled */, localPackagedJars.contains(file) /* packaged */,
                            null /* resolvedCoordinates */, null /* projectPath */));
        }

        for (File file : localPackagedJars) {
            if (!localCompiledJars.contains(file)) {
                localJars.put(file, new JarDependency(file, false /* compiled */, true /* packaged */,
                        null /* resolvedCoordinates */, null /* projectPath */));
            }
        }

        if (extraModelInfo.getMode() != STANDARD && compileClasspath.getResolvedConfiguration().hasError()) {
            for (String dependency : currentUnresolvedDependencies) {
                extraModelInfo.handleSyncError(dependency, SyncIssue.TYPE_UNRESOLVED_DEPENDENCY,
                        String.format("Unable to resolve dependency '%s'", dependency));
            }
        }
        // convert the LibInfo in LibraryDependencyImpl and update the reverseMap
        // with the converted keys
        List<LibraryDependencyImpl> libList = convertLibraryInfoIntoDependency(androidDependencyTree.getAarBundles(),
                librariesToKeep, reverseMap);

        variantDeps.addLibraries(libList);
        variantDeps.addJars(jars);
        variantDeps.addLocalJars(localJars.values());
        configureBuild(variantDeps);
        if (DEBUG_DEPENDENCY) {
            logger.info(project.getName() + ":" + compileClasspath.getName() + "/" + packageClasspath.getName());
            logger.info("<<<<<<<<<<");
        }

        long endtime = System.currentTimeMillis();
        logger.info("[TdependencyManager] finish " + (endtime - endresolve));

    }

    private void configureBuild(VariantDependencies configurationDependencies) {
        addDependsOnTaskInOtherProjects(project.getTasks().getByName(JavaBasePlugin.BUILD_NEEDED_TASK_NAME), true,
                JavaBasePlugin.BUILD_NEEDED_TASK_NAME, "compile");
        addDependsOnTaskInOtherProjects(project.getTasks().getByName(JavaBasePlugin.BUILD_DEPENDENTS_TASK_NAME), false,
                JavaBasePlugin.BUILD_DEPENDENTS_TASK_NAME, "compile");
    }

    /**
     * 解析依赖
     *
     * @param resolvedDependencyContainer
     * @param parent
     * @param resolvedComponentResult
     * @param artifacts
     * @param configDependencies
     * @param indent
     */
    int i = 0;

    private void resolveDependency(ResolvedDependencyContainer resolvedDependencyContainer,
                                   ResolvedDependencyInfo parent, ResolvedComponentResult resolvedComponentResult,
                                   Map<ModuleVersionIdentifier, List<ResolvedArtifact>> artifacts,
                                   VariantDependencies configDependencies, int indent,
                                   CircleDependencyCheck circleDependencyCheck,
                                   CircleDependencyCheck.DependencyNode node, Set<String> resolvedModules) {
        ModuleVersionIdentifier moduleVersion = resolvedComponentResult.getModuleVersion();

        if (configDependencies.getChecker().excluded(moduleVersion)) {
            return;
        }

        if (moduleVersion.getName().equals("support-annotations")
                && moduleVersion.getGroup().equals("com.android.support")) {
            configDependencies.setAnnotationsPresent(true);
        }

        // now loop on all the artifact for this modules.
        List<ResolvedArtifact> moduleArtifacts = artifacts.get(moduleVersion);

        if (null == moduleArtifacts) {
            return;
        }

        ComponentIdentifier id = resolvedComponentResult.getId();
        String gradlePath = (id instanceof ProjectComponentIdentifier) ? ((ProjectComponentIdentifier) id).getProjectPath() : null;

        // 如果同时找到多个依赖，暂时没法判断是那个真正有用
        for (ResolvedArtifact resolvedArtifact : moduleArtifacts) {

            ResolvedDependencyInfo resolvedDependencyInfo = new ResolvedDependencyInfo(moduleVersion.getVersion(),
                    moduleVersion.getGroup(),
                    moduleVersion.getName(),
                    resolvedArtifact.getType(),
                    resolvedArtifact.getClassifier());
            resolvedDependencyInfo.setIndent(indent);
            resolvedDependencyInfo.setGradlePath(gradlePath);
            resolvedDependencyInfo.setResolvedArtifact(resolvedArtifact);

            //TODO
            String moduleVersonString = moduleVersion.toString() + "." + resolvedArtifact.getType() + "." + resolvedArtifact.getClassifier() + "." + indent;
            if (resolvedModules.contains(moduleVersonString)) {
                logger.info(">>> resolve multi times  " + i++ + " " + moduleVersonString);
                continue;
            } else {
                resolvedModules.add(moduleVersonString);
            }

            String path = computeArtifactPath(moduleVersion, resolvedArtifact);
            String name = computeArtifactName(moduleVersion, resolvedArtifact);

            File explodedDir = project.file(project.getBuildDir() + "/" + FD_INTERMEDIATES + "/exploded-"
                    + resolvedArtifact.getType().toLowerCase() + "/" + path);
            resolvedDependencyInfo.setExplodedDir(explodedDir);
            resolvedDependencyInfo.setDependencyName(name);

            if (null == parent) {
                parent = resolvedDependencyInfo;
            } else {
                resolvedDependencyInfo.setParent(parent);
                parent.getChildren().add(resolvedDependencyInfo);
            }
            Set<? extends DependencyResult> dependencies = resolvedComponentResult.getDependencies();
            for (DependencyResult dep : dependencies) {
                if (dep instanceof ResolvedDependencyResult) {
                    ResolvedComponentResult childResolvedComponentResult = ((ResolvedDependencyResult) dep).getSelected();
                    CircleDependencyCheck.DependencyNode childNode = circleDependencyCheck.addDependency(childResolvedComponentResult.getModuleVersion(),
                            node,
                            indent + 1);
                    CircleDependencyCheck.CircleResult circleResult = circleDependencyCheck.checkCircle(logger);
                    if (circleResult.hasCircle) {
                        logger.warning("[CircleDependency]" + StringUtils.join(circleResult.detail, ";"));
                    } else {
                        resolveDependency(resolvedDependencyContainer, parent,
                                ((ResolvedDependencyResult) dep).getSelected(), artifacts, configDependencies,
                                indent + 1, circleDependencyCheck, childNode, resolvedModules);
                    }
                }
            }
            resolvedDependencyContainer.addDependency(resolvedDependencyInfo);
        }

    }

    @NonNull
    private String computeArtifactPath(@NonNull ModuleVersionIdentifier moduleVersion,
                                       @NonNull ResolvedArtifact artifact) {
        StringBuilder pathBuilder = new StringBuilder();

        pathBuilder.append(normalize(logger, moduleVersion,
                moduleVersion.getGroup())).append('/').append(normalize(logger, moduleVersion,
                moduleVersion.getName())).append('/').append(normalize(logger,
                moduleVersion,
                moduleVersion.getVersion()));

        if (artifact.getClassifier() != null && !artifact.getClassifier().isEmpty()) {
            pathBuilder.append('/').append(normalize(logger, moduleVersion, artifact.getClassifier()));
        }

        return pathBuilder.toString();
    }

    @NonNull
    private static String computeArtifactName(@NonNull ModuleVersionIdentifier moduleVersion,
                                              @NonNull ResolvedArtifact artifact) {
        StringBuilder nameBuilder = new StringBuilder();

        nameBuilder.append(moduleVersion.getGroup()).append(':').append(moduleVersion.getName()).append(':').append(moduleVersion.getVersion());

        if (artifact.getClassifier() != null && !artifact.getClassifier().isEmpty()) {
            nameBuilder.append(':').append(artifact.getClassifier());
        }

        return nameBuilder.toString();
    }

    private void ensureConfigured(Configuration config) {
        for (Dependency dependency : config.getAllDependencies()) {
            if (dependency instanceof ProjectDependency) {
                ProjectDependency projectDependency = (ProjectDependency) dependency;
                project.evaluationDependsOn(projectDependency.getDependencyProject().getPath());
                try {
                    ensureConfigured(projectDependency.getProjectConfiguration());
                } catch (Throwable e) {
                    throw new UnknownProjectException(String.format("Cannot evaluate module %s : %s",
                            projectDependency.getName(), e.getMessage()),
                            e);
                }
            }
        }
    }

    private void collectArtifacts(Configuration configuration,
                                  Map<ModuleVersionIdentifier, List<ResolvedArtifact>> artifacts) {

        Set<ResolvedArtifact> allArtifacts;
        if (extraModelInfo.getMode() != STANDARD) {
            allArtifacts = configuration.getResolvedConfiguration().getLenientConfiguration().getArtifacts(Specs.satisfyAll());
        } else {
            allArtifacts = configuration.getResolvedConfiguration().getResolvedArtifacts();
        }

        for (ResolvedArtifact artifact : allArtifacts) {
            ModuleVersionIdentifier id = artifact.getModuleVersion().getId();
            List<ResolvedArtifact> moduleArtifacts = artifacts.get(id);

            if (moduleArtifacts == null) {
                moduleArtifacts = Lists.newArrayList();
                artifacts.put(id, moduleArtifacts);
            }

            if (!moduleArtifacts.contains(artifact)) {
                moduleArtifacts.add(artifact);
            }
        }
    }

    private static void gatherJarDependencies(Set<JarInfo> outJarInfos, Collection<JarInfo> inJarInfos,
                                              boolean compiled, boolean packaged) {
        for (JarInfo jarInfo : inJarInfos) {
            outJarInfos.add(jarInfo);

            if (compiled) {
                jarInfo.setCompiled(true);
            }
            if (packaged) {
                jarInfo.setPackaged(true);
            }

            gatherJarDependencies(outJarInfos, jarInfo.getDependencies(), compiled, packaged);
        }
    }

    private static void gatherAndroidDependencies(Set<LibInfo> outLibInfos, Collection<LibInfo> inLibInfos) {
        for (LibInfo libInfo : inLibInfos) {
            outLibInfos.add(libInfo);
            gatherAndroidDependencies(outLibInfos, libInfo.getLibInfoDependencies());
        }
    }

    private static void gatherJarDependenciesFromLibraries(Set<JarInfo> outJarInfos,
                                                           Collection<LibInfo> inLibraryDependencies) {
        for (LibInfo libInfo : inLibraryDependencies) {
            gatherJarDependencies(outJarInfos, libInfo.getJarDependencies(), true, !libInfo.isOptional());

            gatherJarDependenciesFromLibraries(outJarInfos, libInfo.getLibInfoDependencies());
        }
    }

    private void printIndent(int indent, @NonNull String message) {
        for (int i = 0; i < indent; i++) {
            logger.info("\t");
        }

        logger.info(message);
    }

    /**
     * Adds a dependency on tasks with the specified name in other projects.  The other projects
     * are determined from project lib dependencies using the specified configuration name.
     * These may be projects this project depends on or projects that depend on this project
     * based on the useDependOn argument.
     *
     * @param task                 Task to add dependencies to
     * @param useDependedOn        if true, add tasks from projects this project depends on, otherwise
     *                             use projects that depend on this one.
     * @param otherProjectTaskName name of task in other projects
     * @param configurationName    name of configuration to use to find the other projects
     */
    private static void addDependsOnTaskInOtherProjects(final Task task, boolean useDependedOn,
                                                        String otherProjectTaskName, String configurationName) {
        Project project = task.getProject();
        final Configuration configuration = project.getConfigurations().getByName(configurationName);
        task.dependsOn(configuration.getTaskDependencyFromProjectDependency(useDependedOn, otherProjectTaskName));
    }

    /**
     * Compute a version-less key representing the given coordinates.
     *
     * @param coordinates the coordinate
     * @return the key.
     */
    @NonNull
    private static String computeVersionLessCoordinateKey(@NonNull MavenCoordinates coordinates) {
        StringBuilder sb = new StringBuilder(coordinates.getGroupId());
        sb.append(':').append(coordinates.getArtifactId());
        if (coordinates.getClassifier() != null) {
            sb.append(':').append(coordinates.getClassifier());
        }
        return sb.toString();
    }

    private void skipTestDependency(@NonNull VariantDependencies variantDeps, MavenCoordinates coordinates,
                                    String testedVersion) {
        // same artifact, skip packaging of the dependency in the test app,
        // whether the version is a match or not.

        // if the dependency is present in both tested and test artifact,
        // verify that they are the same version
        if (!testedVersion.equals(coordinates.getVersion())) {
            String artifactInfo = coordinates.getGroupId() + ":" + coordinates.getArtifactId();
            variantDeps.getChecker().addSyncIssue(extraModelInfo.handleSyncError(artifactInfo,
                    SyncIssue.TYPE_MISMATCH_DEP,
                    String.format("Conflict with dependency '%s'. Resolved versions for"
                                    + " app (%s) and test app (%s) differ. See"
                                    + " http://g.co/androidstudio/app-test-app-conflict"
                                    + " for details.",
                            artifactInfo,
                            testedVersion,
                            coordinates.getVersion())));

        } else {
            logger.info(String.format("Removed '%s' from packaging of %s: Already in tested package.", coordinates,
                    variantDeps.getName()));
        }
    }

    private static List<LibraryDependencyImpl> convertLibraryInfoIntoDependency(@NonNull List<AarBundle> libInfos,
                                                                                Set<LibInfo> librariesToKeep,
                                                                                @NonNull Multimap<LibraryDependency, VariantDependencies> reverseMap) {
        List<LibraryDependencyImpl> list = Lists.newArrayListWithCapacity(libInfos.size());

        // since the LibInfos is a graph and the previous "foundLibraries" map ensure we reuse
        // instance where applicable, we'll create a map to keep track of what we have already
        // converted.
        Map<LibInfo, LibraryDependencyImpl> convertedMap = Maps.newIdentityHashMap();

        for (LibInfo libInfo : libInfos) {
            if (librariesToKeep.contains(libInfo)) {
                list.add(convertLibInfo(libInfo, librariesToKeep, reverseMap, convertedMap));
            }
        }

        return list;
    }

    private static LibraryDependencyImpl convertLibInfo(@NonNull LibInfo libInfo, Set<LibInfo> librariesToKeep,
                                                        @NonNull Multimap<LibraryDependency, VariantDependencies> reverseMap,
                                                        @NonNull Map<LibInfo, LibraryDependencyImpl> convertedMap) {
        LibraryDependencyImpl convertedLib = convertedMap.get(libInfo);
        if (convertedLib == null) {
            // first, convert the children.
            @SuppressWarnings("unchecked")
            List<LibInfo> children = (List<LibInfo>) (List<?>) libInfo.getDependencies();
            List<LibraryDependency> convertedChildren = Lists.newArrayListWithCapacity(children.size());

            for (LibInfo child : children) {
                if (librariesToKeep.contains(child)) {
                    convertedChildren.add(convertLibInfo(child, librariesToKeep, reverseMap, convertedMap));
                }
            }

            // now convert the libInfo
            convertedLib = new LibraryDependencyImpl(libInfo.getBundle(), libInfo.getFolder(), convertedChildren,
                    libInfo.getName(), libInfo.getProjectVariant(),
                    libInfo.getProject(), libInfo.getRequestedCoordinates(),
                    libInfo.getResolvedCoordinates(), libInfo.isOptional());

            // add it to the map
            convertedMap.put(libInfo, convertedLib);

            // and update the reversemap
            // get the items associated with the libInfo. Put in a fresh list as the returned
            // collection is backed by the content of the map.
            Collection<VariantDependencies> values = Lists.newArrayList(reverseMap.get(libInfo));
            reverseMap.removeAll(libInfo);
            reverseMap.putAll(convertedLib, values);
        }

        return convertedLib;
    }

}
